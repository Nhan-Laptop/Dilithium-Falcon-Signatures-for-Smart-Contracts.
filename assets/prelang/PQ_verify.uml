@startuml
title Post-Quantum Signature Verification Flow (Dilithium)

partition "Off-chain User Actions / Key Setup" {
    |User / Wallet (Off-Chain)|
    :Generate Dilithium key pair (private & public key);
    :Submit a transaction (L1 or L2) to register Dilithium Public Key (one-time setup);
}

partition "Performing a Protected Action" {
    |User / Wallet (Off-Chain)|
    :Create a message payload (e.g., function call data for `withdraw(amount, to)`);
    :Sign the message hash with Dilithium Private Key;
    note right: This creates the quantum-resistant signature.
    :Call the Smart Contract's protected function, providing the message and signature as arguments;
}

|Sequencer / Mempool (optional L2/Rollup)|
:Transaction enters sequencer/mempool (if using a rollup);

|Smart Contract (On-Chain)|
:Protected function is executed;
:Retrieve user's stored Dilithium Public Key from registry (on-chain storage);
:Call internal Dilithium.verify() function with (PublicKey, message, signature);

if (Signature is valid?) then (yes)
    :Execute the protected logic (e.g., transfer assets, update state);
    :Emit Success Event;
    note right: Optionally include an on-chain attestation or merkle-root of off-chain verification
else (no)
    :Transaction Reverts;
    :Emit Failure Event;
endif

note bottom
  Deployment options and hybrid flows:
   - On-chain verification: direct verify in an on-chain contract (L1 or L2). This can be gas-intensive on EVM L1.
   - Off-chain verification + on-chain attestation: verify signatures off-chain and submit a compact attestation to the chain to save gas.
   - zk-proof assisted verification: generate a succinct proof off-chain and verify the proof on-chain (low verifier cost).
   - Rollups: use a sequencer/mempool and perform verification either in the rollup runtime or via attestations submitted to L1.
end note

stop

@enduml
